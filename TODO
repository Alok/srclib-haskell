█ Milestones
	█ Graph output for `warpdep` works with srcco.
	█ Read about `haskell-names`.
	█ Name-resolve a modules independently of it's peers.
	█ Combine name resolution information for all modules withing
	  a package into a single, graphable object.
	█ Combine name resolution information for all packages
	  into a single, graphable object.
	█ Start graphing!
		█ Graph all top-level bindings as defs and self-refs.
		█ Graph explicit imports as refs.
		█ Graph explicitly imported symbols as refs.
		█ Graph the module-part of symbols.
		  For example, BS should be a reference to Data.ByteString in this example:

		      import Data.ByteString as BS
		      baz = BS.foo

█ Improve the test suite.
	█ Interactive testing with srcco.
		█ Get fast test iterations set up.
	█ I should start doing loose TDD style testing. It makes a ton of
	  sense with this type of program.

█ Strictly separate depresolve from graphing.
  █ Formaize the information that I need from the depresolve phase.
	█ Get depresolve to produce this infomrmaiton, FAST!
	█ Write the graphing code to accept depresolve information up front.
	█ In Main.hs, always run depresolve before graphing, and pass that
	  information to the grapher.

█ Allow available packages to be manually specified.
	█ First step: Always use the greatest available version.
	█ Final version: Actually resolve dependencies.

█ What's the best way to deal with the autotools problem?
	█ I can't parse code without running autotools on some projects.
	█ This makes the process slow and error-prone.
	█ This makes the process system-dependent. It's not a pure function any more!
	█ This forces us to copy the source tree to avoid clobbering it.
	█ This adds a run-time dependency on autotools.
